'use strict';

// tests for createLetter
// Generated by serverless-mocha-plugin

const mochaPlugin = require('serverless-mocha-plugin');
const sinon = require('sinon');
const expect = mochaPlugin.chai.expect;
const request = require('request-promise-native');
const fs = require('fs');
const uuid = require('uuid');
let wrapped = mochaPlugin.getWrapper('createLetter', '/handler.js', 'createLetter');

function readJsonFile(fileName) {
  let rawdata = fs.readFileSync(fileName);  
  return JSON.parse(rawdata.toString());  
}

function readTextFile(fileName) {
  return fs.readFileSync(fileName).toString();
}

describe('createLetter', () => {
  before((done) => {
    done();
  });

  it('works when passed valid JSON', () => {
    const mockId = '00000000-0000-0000-0000-000000000000';
    const mockCurrentTime = new Date(2018,1,1);
    var event = { 
      headers: { "content-type": "application/json" }, 
      body: readTextFile('test/data/createLetterValidInputBody.json')
    }

    const requestStub = sinon.stub(request, 'post').resolves();

    // lock down the timestamp and unique ID in the request call
    sinon.stub(Date, 'now').returns(mockCurrentTime); 
    sinon.stub(uuid, 'v4').returns(mockId);

    return wrapped.run(event).then((response) => {
      expect(response.statusCode).to.be.equal(200);
      expect(requestStub.calledOnce).to.be.true;
      const requestParam = requestStub.firstCall.args[0];
      expect(requestParam.url).to.be.equal(process.env.SLACK_WEBHOOK_URL);

      var parsedBody = requestParam.body;
      var expectedBody = readJsonFile('test/data/createLetterExpectedRequestBody.json');

      expect(parsedBody).to.deep.equal(expectedBody);
      
      expect(requestParam.json).to.be.true;
      
    });
  });

  it('fails when given a non-JSON body', () => {
    // keep test output clean, avoid logging the failure details
    var consoleStub = sinon.stub(console, 'log');
    var event = { headers: { "content-type": "application/json" }, body: "asdf" }
    return wrapped.run(event).then((response) => {
      consoleStub.restore();
      expect(response.statusCode).to.be.equal(400);
      expect(response.body).to.be.equal("Bad request: request is not valid JSON");
    });
  });
});
